# Generated stub schema (best-effort)
# Source docs:
# - graphql/AccountLiveBalance.graphql
# - graphql/Accounts.graphql
# - graphql/Budgets.graphql
# - graphql/Categories.graphql
# - graphql/Institution.graphql
# - graphql/InvestmentSettings.graphql
# - graphql/MonthlySpend.graphql
# - graphql/Networth.graphql
# - graphql/NetworthLiveBalance.graphql
# - graphql/NetworthSettings.graphql
# - graphql/Recurrings.graphql
# - graphql/Spends.graphql
# - graphql/Subscription.graphql
# - graphql/Tags.graphql
# - graphql/TransactionSummary.graphql
# - graphql/Transactions.graphql
# - graphql/TransactionsFeed.graphql
# - graphql/UpcomingRecurrings.graphql
# - graphql/User.graphql
# - graphql/WaitlistCheck.graphql

scalar JSON

schema { query: Query }

union CategoryIconUnion = EmojiUnicode | Genmoji

union GoalIconUnion = EmojiUnicode | Genmoji

union InstitutionLogoFullUnion = LogoBase64 | LogoUrl

union InstitutionLogoUnion = LogoBase64 | LogoUrl

union QueryTransactionsFeedEdgesNodeUnion = Transaction | TransactionMonth

union RecurringIconUnion = EmojiUnicode | Genmoji

union SubscriptionPromotionDescriptionEmojiUnion = EmojiUnicode | Genmoji

type Account {
  accountLink: AccountAccountLink
  balance: JSON
  color: JSON
  hasHistoricalUpdates: JSON
  hasLiveBalance: JSON
  id: ID!
  institutionId: ID
  isManual: JSON
  isUserClosed: JSON
  isUserHidden: JSON
  itemId: ID
  latestBalanceUpdate: JSON
  limit: JSON
  liveBalance: JSON
  mask: JSON
  name: JSON
  subType: JSON
  type: JSON
}

type AccountAccountLink {
  account: Account
  type: JSON
}

type AccountBalanceHistory {
  balance: JSON
  date: JSON
}

type AppleAppStorePaymentMethod {
  id: ID!
}

type CardPaymentMethod {
  brand: JSON
  id: ID!
  mask: JSON
}

type Category {
  budget(isRolloverEnabled: Boolean): JSON
  canBeDeleted: JSON
  childCategories: Category
  colorName: JSON
  icon: CategoryIconUnion
  id: ID!
  isExcluded: JSON
  isRolloverDisabled: JSON
  name: JSON
  spend: CategorySpend
  templateId: ID
}

type CategoryBudget {
  current: CategoryMonthlyBudget
  histories: CategoryMonthlyBudget
}

type CategoryMonthlyBudget {
  amount: JSON
  childAmount: JSON
  childRolloverAmount: JSON
  goalAmount: JSON
  id: ID!
  month: JSON
  resolvedAmount: JSON
  rolloverAmount: JSON
  unassignedAmount: JSON
  unassignedRolloverAmount: JSON
}

type CategoryMonthlySpent {
  amount: JSON
  comparisonAmount: JSON
  id: ID!
  month: JSON
  unpaidRecurringAmount: JSON
}

type CategorySpend {
  current: CategoryMonthlySpent
  histories: CategoryMonthlySpent
}

type ClaimedSubscriptionPromotion {
  endsOn: JSON
  promotion: SubscriptionPromotion
}

type CopilotGiftSubscription {
  currentPeriodEndsAt: JSON
  id: ID!
  promotions: ClaimedSubscriptionPromotion
  state: JSON
}

type CopilotPaidSubscription {
  billing: SubscriptionBilling
  id: ID!
  plan: SubscriptionPlan
  promotions: ClaimedSubscriptionPromotion
  state: JSON
}

type DepositoryAccountPaymentMethod {
  account: DepositoryAccountPaymentMethodAccount
  id: ID!
}

type DepositoryAccountPaymentMethodAccount {
  institutionId: ID
  mask: JSON
  name: JSON
}

type EmojiUnicode {
  unicode: JSON
}

type Genmoji {
  id: ID!
  src: JSON
}

type Goal {
  icon: GoalIconUnion
  id: ID!
  name: JSON
}

type Institution {
  color: JSON
  displayType: JSON
  id: ID!
  logo: InstitutionLogoUnion
  logoFull: InstitutionLogoFullUnion
  name: JSON
  providers: ProviderInstitution
  type: JSON
  url: JSON
}

type LogoBase64 {
  content: JSON
  contentType: JSON
}

type LogoUrl {
  src: JSON
}

type NetworthHistory {
  assets: JSON
  date: JSON
  debt: JSON
}

type Onboarding {
  isCompleted: JSON
  lastCompletedStep: JSON
}

type ProviderInstitution {
  connectionType: JSON
  id: ID!
  name: JSON
}

type Query {
  accountLiveBalance(accountId: ID!, itemId: ID!): JSON
  accounts(filter: AccountFilter): JSON
  categories: Category
  categoriesTotal: QueryCategoriesTotal
  institution(id: ID!): JSON
  monthlySpending: QueryMonthlySpending
  networthHistory(timeFrame: TimeFrame): JSON
  networthLiveBalance: NetworthHistory
  recurrings(filter: RecurringFilter): JSON
  subscription: QuerySubscription
  tags: Tag
  transactions(after: String, before: String, filter: TransactionFilter, first: Int, last: Int, sort: [TransactionSort!]): JSON
  transactionsFeed(after: String, before: String, filter: TransactionFilter, first: Int, last: Int, sort: [TransactionSort!]): JSON
  transactionsSummary(filter: TransactionFilter): JSON
  unpaidUpcomingRecurrings: Recurring
  user: QueryUser
}

type QueryCategoriesTotal {
  budget: CategoryBudget
  spend: QueryCategoriesTotalSpend
}

type QueryCategoriesTotalSpend {
  current: CategoryMonthlySpent
  histories: CategoryMonthlySpent
}

type QueryMonthlySpending {
  comparisonAmount: JSON
  date: JSON
  id: ID!
  totalAmount: JSON
}

type QuerySubscription {
  billing: SubscriptionBilling
  currentPeriodEndsAt: JSON
  id: ID!
  plan: SubscriptionPlan
  promotions: ClaimedSubscriptionPromotion
  state: JSON
}

type QueryTransactionsFeed {
  edges: QueryTransactionsFeedEdges
  pageInfo: QueryTransactionsFeedPageInfo
}

type QueryTransactionsFeedEdges {
  cursor: JSON
  node: QueryTransactionsFeedEdgesNodeUnion
}

type QueryTransactionsFeedPageInfo {
  endCursor: JSON
  hasNextPage: JSON
  hasPreviousPage: JSON
  startCursor: JSON
}

type QueryTransactionsSummary {
  totalIncome: JSON
  totalNetIncome: JSON
  totalSpent: JSON
  transactionsCount: JSON
}

type QueryUser {
  budgetingConfig: QueryUserBudgetingConfig
  id: ID!
  intercomUserHash: JSON
  investmentConfig: QueryUserInvestmentConfig
  networthConfig: QueryUserNetworthConfig
  onboarding: Onboarding
  serviceEndsOn: JSON
  termsStatus: JSON
}

type QueryUserBudgetingConfig {
  isEnabled: JSON
  rolloversConfig: QueryUserBudgetingConfigRolloversConfig
}

type QueryUserBudgetingConfigRolloversConfig {
  categories: QueryUserBudgetingConfigRolloversConfigCategories
  isEnabled: JSON
  startDate: JSON
}

type QueryUserBudgetingConfigRolloversConfigCategories {
  canBeDeleted: JSON
  colorName: JSON
  id: ID!
  isExcluded: JSON
  isRolloverDisabled: JSON
  name: JSON
}

type QueryUserInvestmentConfig {
  benchmarkHoldingId: ID
  excludedAccounts: QueryUserInvestmentConfigExcludedAccounts
  liveBalance: JSON
}

type QueryUserInvestmentConfigExcludedAccounts {
  id: ID!
  itemId: ID
}

type QueryUserNetworthConfig {
  combinesAssetsAndDebt: JSON
  excludedAccounts: QueryUserNetworthConfigExcludedAccounts
  isSingleLine: JSON
}

type QueryUserNetworthConfigExcludedAccounts {
  id: ID!
  itemId: ID
}

type Recurring {
  categoryId: ID
  emoji: JSON
  frequency: JSON
  icon: RecurringIconUnion
  id: ID!
  name: JSON
  nextPaymentAmount: JSON
  nextPaymentDate: JSON
  payments: RecurringPayment
  rule: RecurringRule
  state: JSON
}

type RecurringPayment {
  amount: JSON
  date: JSON
  isPaid: JSON
}

type RecurringRule {
  days: JSON
  maxAmount: JSON
  minAmount: JSON
  nameContains: JSON
}

type SubscriptionBilling {
  currentPeriodAmount: JSON
  currentPeriodEndsAt: JSON
  nextPeriodAmount: JSON
  paymentFailure: SubscriptionBillingPaymentFailure
  paymentMethod: SubscriptionBillingPaymentMethod
}

type SubscriptionBillingPaymentFailure {
  reason: JSON
}

type SubscriptionBillingPaymentMethod {
  account: SubscriptionBillingPaymentMethodAccount
  brand: JSON
  id: ID!
  mask: JSON
}

type SubscriptionBillingPaymentMethodAccount {
  institutionId: ID
  mask: JSON
  name: JSON
}

type SubscriptionPlan {
  amount: JSON
  id: ID!
  interval: JSON
  type: JSON
}

type SubscriptionPromotion {
  code: JSON
  description: SubscriptionPromotionDescription
  id: ID!
  type: JSON
  value: JSON
}

type SubscriptionPromotionDescription {
  emoji: SubscriptionPromotionDescriptionEmojiUnion
  text: JSON
}

type Tag {
  colorName: JSON
  id: ID!
  name: JSON
}

type Transaction {
  accountId: ID
  amount: JSON
  categoryId: ID
  createdAt: JSON
  date: JSON
  goal: Goal
  id: ID!
  isPending: JSON
  isReviewed: JSON
  itemId: ID
  name: JSON
  recurringId: ID
  suggestedCategoryIds: JSON
  tags: Tag
  tipAmount: JSON
  type: JSON
  userNotes: JSON
}

type TransactionMonth {
  amount: JSON
  id: ID!
  month: JSON
}

type TransactionPagination {
  edges: TransactionPaginationEdges
  pageInfo: TransactionPaginationPageInfo
}

type TransactionPaginationEdges {
  cursor: JSON
  node: Transaction
}

type TransactionPaginationPageInfo {
  endCursor: JSON
  hasNextPage: JSON
  hasPreviousPage: JSON
  startCursor: JSON
}

input AccountFilter {
  _stub: JSON
}

input RecurringFilter {
  _stub: JSON
}

input TimeFrame {
  _stub: JSON
}

input TransactionFilter {
  _stub: JSON
}

input TransactionSort {
  _stub: JSON
}

